# 第二章 信息的表述和处理
## 2.1 信息存储  
  大多数计算机使用8位的块（即一个字节）作为最小的可寻址内存单位。
  ### 2.1.1 十六进制表示法  
    一个字节由8位组成，他的值域是00000000~11111111，这种书写方法不便，所以使用十六进制表示，为00~FF  
    二进制转十六进制：  
      0011 1100 1010 1101 1011 0011  
         3    C    A    D    B    3
  ### 2.1.2 字数据大小
    字长（word size）指明指针数据的标准大小（normal size），虚拟地址根据字长进行编码。所以，字长决定了  
    虚拟地址空间的最大值。对32位字长的机器而言，虚拟地址范围是0 ~ 2³²-1
  ### 2.1.3 寻址和字节顺序
    小端法：最低有效字节在前面
    大端法：最高有效字节在前面

    例如数据0x01234567（左边是高字节，右边是低字节）
    小端法：0x67 0x45 0x23 0x01
    大端法：0x01 0x23 0x45 0x67
  ### 2.1.4 表示字符串
  ### 2.1.5 表示代码
    int sum(int x, int y) {
      return x + y;
    }
    
    该函数编译成的机器码：
    Linux 32  55 89 e5 Sb 45 Oc 03 45 08 c9 c3
    Windows   55 89 e5 Sb 45 Oc 03 45 08 5d c3
    Sun       81 c3 eO 08 90 02 00 09
    Linux 64  55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3
    
    每个系统的机器码是不同的，所以各个平台并不兼容。
  ### 2.1.9 C语言中的移位运算
    x << k 表示将x的二进制值向左移动k位，丢弃最高的k位，最右端补k个0。
    右移运算分为逻辑右移和算术右移。
      逻辑右移：和左移类似，左端补k个0。
      算术右移：在左端补k个最高有效位的值。

## 2.2 整数表示  
  ### 2.2.2 无符号数的编码
    二进制位到十进制整数的映射：
    B2U(0001) = 0 * 2³ + 0 * 2² + 0 * 2¹ + 1 * 2º = 1
    B2U(0101) = 0 * 2³ + 1 * 2² + 0 * 2¹ + 1 * 2º = 5
  ### 2.2.3 补码编码
    最高有效位表示负权：
    B2T(0001) = -0 * 2³ + 0 * 2² + 0 * 2¹ + 1 * 2º = 1
    B2T(1101) = -1 * 2³ + 1 * 2² + 0 * 2¹ + 1 * 2º = -3
  ### 2.2.4 有符号和无符号之间的转换
    有符号和无符号之间的类型转换只是改变了解释位的方式，位值仍然不变。  
    -12345的16位补码表示与53191的16位无符号表示是完全一样的。
    补码转换为无符号数：  
      T2U(x) = x >= 0 : x ;
               x < 0  : x + 2 ^ w;
      假设w为16。  
        补码12345转无符号仍然为 12345
        补码-12345转无符号为 12345 + 2 ^ 16 = -12345 + 65536 = 53791
  ### 2.2.6 扩展一个数字的位表示
    要将无符号数转换成更大的数据类型，只需要将它的位值开头增加相应位数的0